// 2: .assign.assignTester.run: 
// 3:                           push, rbp
rex(48)op(ff)modR/M(f5)
// 4:                           mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 5:                           mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 6:                           pop, rbp
rex(48)op(8f)modR/M(c5)
// 7:                           ret
op(c3)
// 10: .assign.assignTester.readFromSubObject: 
// 11:                                         push, rbp         
rex(48)op(ff)modR/M(f5)
// 12:                                         mov, rbp, rsp     
rex(48)op(89)modR/M(e5)
// 13:                                         mov, r8, [rdx+16] ; =
rex(4c)op(8b)modR/M(42)d8(10)
// 14:                                         mov, rsp, rbp     
rex(48)op(89)modR/M(ec)
// 15:                                         pop, rbp          
rex(48)op(8f)modR/M(c5)
// 16:                                         ret               
op(c3)
// 19: .assign.assignTester.writeIntoSubObject: 
// 20:                                          push, rbp             
rex(48)op(ff)modR/M(f5)
// 21:                                          mov, rbp, rsp         
rex(48)op(89)modR/M(e5)
// 22:                                          sub, rsp, 24          
rex(48)op(83)modR/M(ec)i8(18)
// 23:                                          lea, rcx, [rbp-24]    ; a
rex(48)op(8d)modR/M(4d)d8(e8)
// 24:                                          sub, rsp, 32          
rex(48)op(83)modR/M(ec)i8(20)
// 25:                                          call, .assign.A_sctor ; (call label)
op(e8)co32(00-00-00-00)
// 26:                                          add, rsp, 32          
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 27:                                          mov, [rcx+16], 7      ; =
rex(48)op(c7)modR/M(41)d8(10)i32(07-00-00-00)
// 28:                                          sub, rsp, 32          
rex(48)op(83)modR/M(ec)i8(20)
// 29:                                          call, .assign.A_sdtor ; (call label)
op(e8)co32(00-00-00-00)
// 30:                                          add, rsp, 32          
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 31:                                          mov, rsp, rbp         
rex(48)op(89)modR/M(ec)
// 32:                                          pop, rbp              
rex(48)op(8f)modR/M(c5)
// 33:                                          ret                   
op(c3)
// 36: .assign.assignTester.readFromSubSubObject: 
// 37:                                            push, rbp          
rex(48)op(ff)modR/M(f5)
// 38:                                            push, rbx          
rex(48)op(ff)modR/M(f3)
// 39:                                            push, rdi          
rex(48)op(ff)modR/M(f7)
// 40:                                            mov, rbp, rsp      
rex(48)op(89)modR/M(e5)
// 41:                                            mov, rbx, [rdi+16] ; fieldaccess: owner of _x
rex(48)op(8b)modR/M(5f)d8(10)
// 42:                                            mov, r8, [rbx+16]  ; =
rex(4c)op(8b)modR/M(43)d8(10)
// 43:                                            mov, rsp, rbp      
rex(48)op(89)modR/M(ec)
// 44:                                            pop, rdi           
rex(48)op(8f)modR/M(c7)
// 45:                                            pop, rbx           
rex(48)op(8f)modR/M(c3)
// 46:                                            pop, rbp           
rex(48)op(8f)modR/M(c5)
// 47:                                            ret                
op(c3)
// 50: .assign.assignTester.writeIntoSubSubObject: 
// 51:                                             push, rbp             
rex(48)op(ff)modR/M(f5)
// 52:                                             push, rbx             
rex(48)op(ff)modR/M(f3)
// 53:                                             mov, rbp, rsp         
rex(48)op(89)modR/M(e5)
// 54:                                             sub, rsp, 24          
rex(48)op(83)modR/M(ec)i8(18)
// 55:                                             lea, rcx, [rbp-24]    ; wrong
rex(48)op(8d)modR/M(4d)d8(e8)
// 56:                                             sub, rsp, 32          
rex(48)op(83)modR/M(ec)i8(20)
// 57:                                             call, .assign.A_sctor ; (call label)
op(e8)co32(00-00-00-00)
// 58:                                             add, rsp, 32          
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 59:                                             mov, rbx, [rcx+16]    ; fieldaccess: owner of _x
rex(48)op(8b)modR/M(59)d8(10)
// 60:                                             mov, [rbx+16], 7      ; =
rex(48)op(c7)modR/M(43)d8(10)i32(07-00-00-00)
// 61:                                             sub, rsp, 32          
rex(48)op(83)modR/M(ec)i8(20)
// 62:                                             call, .assign.A_sdtor ; (call label)
op(e8)co32(00-00-00-00)
// 63:                                             add, rsp, 32          
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 64:                                             mov, rsp, rbp         
rex(48)op(89)modR/M(ec)
// 65:                                             pop, rbx              
rex(48)op(8f)modR/M(c3)
// 66:                                             pop, rbp              
rex(48)op(8f)modR/M(c5)
// 67:                                             ret                   
op(c3)
// 70: .assign.assignTester.bopAssociativity: 
// 71:                                        push, rbp         
rex(48)op(ff)modR/M(f5)
// 72:                                        push, rbx         
rex(48)op(ff)modR/M(f3)
// 73:                                        push, rdi         
rex(48)op(ff)modR/M(f7)
// 74:                                        mov, rbp, rsp     
rex(48)op(89)modR/M(e5)
// 75:                                        sub, rsp, 8       
rex(48)op(83)modR/M(ec)i8(08)
// 76:                                        mov, rbx, 1       
rex(48)op(bb)i64(01-00-00-00,00-00-00-00)
// 77:                                        add, rbx, 2       
rex(48)op(81)modR/M(c3)i32(02-00-00-00)
// 78:                                        mov, rdi, rbx     
rex(48)op(89)modR/M(df)
// 79:                                        add, rdi, 3       
rex(48)op(81)modR/M(c7)i32(03-00-00-00)
// 80:                                        mov, [rbp-8], rdi ; =
rex(48)op(89)modR/M(7d)d8(f8)
// 81:                                        mov, rsp, rbp     
rex(48)op(89)modR/M(ec)
// 82:                                        pop, rdi          
rex(48)op(8f)modR/M(c7)
// 83:                                        pop, rbx          
rex(48)op(8f)modR/M(c3)
// 84:                                        pop, rbp          
rex(48)op(8f)modR/M(c5)
// 85:                                        ret               
op(c3)
// 88: .assign.assignTester.cctor: 
// 89:                             push, rbp
rex(48)op(ff)modR/M(f5)
// 90:                             mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 91:                             mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 92:                             pop, rbp
rex(48)op(8f)modR/M(c5)
// 93:                             ret
op(c3)
// 96: .assign.assignTester.cdtor: 
// 97:                             push, rbp
rex(48)op(ff)modR/M(f5)
// 98:                             mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 99:                             mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 100:                             pop, rbp
rex(48)op(8f)modR/M(c5)
// 101:                             ret
op(c3)
// 104: .assign.A.cctor: 
// 105:                  push, rbp       
rex(48)op(ff)modR/M(f5)
// 106:                  push, rbx       
rex(48)op(ff)modR/M(f3)
// 107:                  mov, rbp, rsp   
rex(48)op(89)modR/M(e5)
// 108:                  mov, [rbx+8], 0 ; =
rex(48)op(c7)modR/M(43)d8(08)i32(00-00-00-00)
// 109:                  mov, rsp, rbp   
rex(48)op(89)modR/M(ec)
// 110:                  pop, rbx        
rex(48)op(8f)modR/M(c3)
// 111:                  pop, rbp        
rex(48)op(8f)modR/M(c5)
// 112:                  ret             
op(c3)
// 115: .assign.A.cdtor: 
// 116:                  push, rbp
rex(48)op(ff)modR/M(f5)
// 117:                  mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 118:                  mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 119:                  pop, rbp
rex(48)op(8f)modR/M(c5)
// 120:                  ret
op(c3)
// 123: .assign.B.cctor: 
// 124:                  push, rbp        
rex(48)op(ff)modR/M(f5)
// 125:                  push, rbx        
rex(48)op(ff)modR/M(f3)
// 126:                  mov, rbp, rsp    
rex(48)op(89)modR/M(e5)
// 127:                  mov, [rbx+8], 0  ; =
rex(48)op(c7)modR/M(43)d8(08)i32(00-00-00-00)
// 128:                  mov, [rbx+16], 0 ; =
rex(48)op(c7)modR/M(43)d8(10)i32(00-00-00-00)
// 129:                  mov, rsp, rbp    
rex(48)op(89)modR/M(ec)
// 130:                  pop, rbx         
rex(48)op(8f)modR/M(c3)
// 131:                  pop, rbp         
rex(48)op(8f)modR/M(c5)
// 132:                  ret              
op(c3)
// 135: .assign.B.cdtor: 
// 136:                  push, rbp
rex(48)op(ff)modR/M(f5)
// 137:                  mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 138:                  mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 139:                  pop, rbp
rex(48)op(8f)modR/M(c5)
// 140:                  ret
op(c3)
// 143: .assign.A_vtbl_inst:
// 146: .assign.B_vtbl_inst:
// 149: .assign.assignTester_vtbl_inst: 
// 150:                                 goto, .assign.assignTester.run
op(e9)co32(00-00-00-00)
// 153: .assign.A_sctor: 
// 154:                  push, rbp                              
rex(48)op(ff)modR/M(f5)
// 155:                  push, rbx                              
rex(48)op(ff)modR/M(f3)
// 156:                  mov, rbp, rsp                          
rex(48)op(89)modR/M(e5)
// 157:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 158:                  call, .sht.core.object_sctor           ; (call label)
op(e8)co32(00-00-00-00)
// 159:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 160:                  lea, rbx, qwordptr .assign.A_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 161:                  mov, [rcx], rbx                        ; =
rex(48)op(89)modR/M(19)
// 162:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 163:                  call, .assign.A.cctor                  ; (call label)
op(e8)co32(00-00-00-00)
// 164:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 165:                  mov, rsp, rbp                          
rex(48)op(89)modR/M(ec)
// 166:                  pop, rbx                               
rex(48)op(8f)modR/M(c3)
// 167:                  pop, rbp                               
rex(48)op(8f)modR/M(c5)
// 168:                  ret                                    
op(c3)
// 171: .assign.A_sdtor: 
// 172:                  push, rbp                              
rex(48)op(ff)modR/M(f5)
// 173:                  push, rbx                              
rex(48)op(ff)modR/M(f3)
// 174:                  mov, rbp, rsp                          
rex(48)op(89)modR/M(e5)
// 175:                  lea, rbx, qwordptr .assign.A_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 176:                  mov, [rcx], rbx                        ; =
rex(48)op(89)modR/M(19)
// 177:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 178:                  call, .assign.A.cdtor                  ; (call label)
op(e8)co32(00-00-00-00)
// 179:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 180:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 181:                  call, .sht.core.object_sdtor           ; (call label)
op(e8)co32(00-00-00-00)
// 182:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 183:                  mov, rsp, rbp                          
rex(48)op(89)modR/M(ec)
// 184:                  pop, rbx                               
rex(48)op(8f)modR/M(c3)
// 185:                  pop, rbp                               
rex(48)op(8f)modR/M(c5)
// 186:                  ret                                    
op(c3)
// 189: .assign.B_sctor: 
// 190:                  push, rbp                              
rex(48)op(ff)modR/M(f5)
// 191:                  push, rbx                              
rex(48)op(ff)modR/M(f3)
// 192:                  mov, rbp, rsp                          
rex(48)op(89)modR/M(e5)
// 193:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 194:                  call, .sht.core.object_sctor           ; (call label)
op(e8)co32(00-00-00-00)
// 195:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 196:                  lea, rbx, qwordptr .assign.B_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 197:                  mov, [rcx], rbx                        ; =
rex(48)op(89)modR/M(19)
// 198:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 199:                  call, .assign.B.cctor                  ; (call label)
op(e8)co32(00-00-00-00)
// 200:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 201:                  mov, rsp, rbp                          
rex(48)op(89)modR/M(ec)
// 202:                  pop, rbx                               
rex(48)op(8f)modR/M(c3)
// 203:                  pop, rbp                               
rex(48)op(8f)modR/M(c5)
// 204:                  ret                                    
op(c3)
// 207: .assign.B_sdtor: 
// 208:                  push, rbp                              
rex(48)op(ff)modR/M(f5)
// 209:                  push, rbx                              
rex(48)op(ff)modR/M(f3)
// 210:                  mov, rbp, rsp                          
rex(48)op(89)modR/M(e5)
// 211:                  lea, rbx, qwordptr .assign.B_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 212:                  mov, [rcx], rbx                        ; =
rex(48)op(89)modR/M(19)
// 213:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 214:                  call, .assign.B.cdtor                  ; (call label)
op(e8)co32(00-00-00-00)
// 215:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 216:                  sub, rsp, 32                           
rex(48)op(83)modR/M(ec)i8(20)
// 217:                  call, .sht.core.object_sdtor           ; (call label)
op(e8)co32(00-00-00-00)
// 218:                  add, rsp, 32                           
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 219:                  mov, rsp, rbp                          
rex(48)op(89)modR/M(ec)
// 220:                  pop, rbx                               
rex(48)op(8f)modR/M(c3)
// 221:                  pop, rbp                               
rex(48)op(8f)modR/M(c5)
// 222:                  ret                                    
op(c3)
// 225: .assign.assignTester_sctor: 
// 226:                             push, rbp                                         
rex(48)op(ff)modR/M(f5)
// 227:                             push, rbx                                         
rex(48)op(ff)modR/M(f3)
// 228:                             mov, rbp, rsp                                     
rex(48)op(89)modR/M(e5)
// 229:                             sub, rsp, 32                                      
rex(48)op(83)modR/M(ec)i8(20)
// 230:                             call, .sht.cons.program_sctor                     ; (call label)
op(e8)co32(00-00-00-00)
// 231:                             add, rsp, 32                                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 232:                             lea, rbx, qwordptr .assign.assignTester_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 233:                             mov, [rcx], rbx                                   ; =
rex(48)op(89)modR/M(19)
// 234:                             sub, rsp, 32                                      
rex(48)op(83)modR/M(ec)i8(20)
// 235:                             call, .assign.assignTester.cctor                  ; (call label)
op(e8)co32(00-00-00-00)
// 236:                             add, rsp, 32                                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 237:                             mov, rsp, rbp                                     
rex(48)op(89)modR/M(ec)
// 238:                             pop, rbx                                          
rex(48)op(8f)modR/M(c3)
// 239:                             pop, rbp                                          
rex(48)op(8f)modR/M(c5)
// 240:                             ret                                               
op(c3)
// 243: .assign.assignTester_sdtor: 
// 244:                             push, rbp                                         
rex(48)op(ff)modR/M(f5)
// 245:                             push, rbx                                         
rex(48)op(ff)modR/M(f3)
// 246:                             mov, rbp, rsp                                     
rex(48)op(89)modR/M(e5)
// 247:                             lea, rbx, qwordptr .assign.assignTester_vtbl_inst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 248:                             mov, [rcx], rbx                                   ; =
rex(48)op(89)modR/M(19)
// 249:                             sub, rsp, 32                                      
rex(48)op(83)modR/M(ec)i8(20)
// 250:                             call, .assign.assignTester.cdtor                  ; (call label)
op(e8)co32(00-00-00-00)
// 251:                             add, rsp, 32                                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 252:                             sub, rsp, 32                                      
rex(48)op(83)modR/M(ec)i8(20)
// 253:                             call, .sht.cons.program_sdtor                     ; (call label)
op(e8)co32(00-00-00-00)
// 254:                             add, rsp, 32                                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 255:                             mov, rsp, rbp                                     
rex(48)op(89)modR/M(ec)
// 256:                             pop, rbx                                          
rex(48)op(8f)modR/M(c3)
// 257:                             pop, rbp                                          
rex(48)op(8f)modR/M(c5)
// 258:                             ret                                               
op(c3)
