// 2: .main.startLabel:
// 3: .data, "~~ lats start ~~" <b> 0 
_strdata(7e-7e-20-6c,61-74-73-20,73-74-61-72,74-20-7e-7e)_intdata(00)
// 6: .main.endLabel:
// 7: .data, "~~ lats end ~~" <b> 0 
_strdata(7e-7e-20-6c,61-74-73-20,65-6e-64-20,7e-7e)_intdata(00)
// 10: .main.passLabel:
// 11: .data, "    pass" <b> 0 
_strdata(20-20-20-20,70-61-73-73)_intdata(00)
// 14: .main.failLabel:
// 15: .data, "    !!!!!!!! FAIL !!!!!!!!" <b> 0 
_strdata(20-20-20-20,21-21-21-21,21-21-21-21,20-46-41-49,4c-20-21-21,21-21-21-21,21-21)_intdata(00)
// 18: .entrypoint: 
// 19:              push, rbp                           
rex(48)op(ff)modR/M(f5)
// 20:              mov, rbp, rsp                       
rex(48)op(89)modR/M(e5)
// 21:              sub, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 22:              lea, rcx, qwordptr .main.startLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 23:              call, ._print                       ; (call label)
op(e8)co32(00-00-00-00)
// 24:              add, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 25:              sub, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 26:              call, .splitter.test                ; (call label)
op(e8)co32(00-00-00-00)
// 27:              add, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 28:              sub, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 29:              call, .combiner.test                ; (call label)
op(e8)co32(00-00-00-00)
// 30:              add, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 31:              sub, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 32:              lea, rcx, qwordptr .main.endLabel   
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 33:              call, ._print                       ; (call label)
op(e8)co32(00-00-00-00)
// 34:              add, rsp, 32                        ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 35:              mov, rsp, rbp                       
rex(48)op(89)modR/M(ec)
// 36:              pop, rbp                            
rex(48)op(8f)modR/M(c5)
// 37:              ret                                 
op(c3)
// 40: .main.check:         
// 41:                      push, rbp                          
rex(48)op(ff)modR/M(f5)
// 42:                      push, rbx                          
rex(48)op(ff)modR/M(f3)
// 43:                      mov, rbp, rsp                      
rex(48)op(89)modR/M(e5)
// 44:                      sub, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(83)modR/M(ec)i8(28)
// 45:                      mov, rbx, rdx                      ; (preserve) [combiner]
rex(48)op(89)modR/M(d3)
// 46:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 47:                      add, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(81)modR/M(c4)i32(28-00-00-00)
// 48:                      cmp, rbx, 0                        
rex(48)op(81)modR/M(fb)i32(00-00-00-00)
// 49:                      je, .main.check.else.0             
op(0f-84)co32(00-00-00-00)
// 50:                      sub, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(83)modR/M(ec)i8(28)
// 51:                      lea, rcx, qwordptr .main.passLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 52:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 53:                      add, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(81)modR/M(c4)i32(28-00-00-00)
// 54:                      goto, .main.check.endif.1          
op(e9)co32(00-00-00-00)
// 56: .main.check.else.0:  
// 57:                      sub, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(83)modR/M(ec)i8(28)
// 58:                      lea, rcx, qwordptr .main.failLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 59:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 60:                      add, rsp, 40                       ; 40 = (passing size)32 + (align pad)8
rex(48)op(81)modR/M(c4)i32(28-00-00-00)
// 61:                      goto, .main.check.endif.1          
op(e9)co32(00-00-00-00)
// 63: .main.check.endif.1: 
// 64:                      mov, rsp, rbp                      
rex(48)op(89)modR/M(ec)
// 65:                      pop, rbx                           
rex(48)op(8f)modR/M(c3)
// 66:                      pop, rbp                           
rex(48)op(8f)modR/M(c5)
// 67:                      ret                                
op(c3)
// 70: .combiner.label:
// 71: .data, "- combiner" <b> 0 
_strdata(2d-20-63-6f,6d-62-69-6e,65-72)_intdata(00)
// 74: .combiner.test.label:
// 75: .data, "  - simple" <b> 0 
_strdata(20-20-2d-20,73-69-6d-70,6c-65)_intdata(00)
// 78: .combiner.subFunc2: 
// 79:                     push, rbp
rex(48)op(ff)modR/M(f5)
// 80:                     mov, rbp, rsp
rex(48)op(89)modR/M(e5)
// 81:                     mov, rsp, rbp
rex(48)op(89)modR/M(ec)
// 82:                     pop, rbp
rex(48)op(8f)modR/M(c5)
// 83:                     ret
op(c3)
// 86: .combiner.subFunc1: 
// 87:                     push, rbp                               
rex(48)op(ff)modR/M(f5)
// 88:                     push, rbx                               
rex(48)op(ff)modR/M(f3)
// 89:                     mov, rbp, rsp                           
rex(48)op(89)modR/M(e5)
// 90:                     sub, rsp, 8                             
rex(48)op(83)modR/M(ec)i8(08)
// 91:                     xor, rbx, rbx                           
rex(48)op(31)modR/M(db)
// 92:                     cmp, rdx, 2                             
rex(48)op(81)modR/M(fa)i32(02-00-00-00)
// 93:                     setet, rbx                              
rex(48)op(0f-94)modR/M(c3)
// 94:                     mov, [rbp-8], rbx                       ; =
rex(48)op(89)modR/M(5d)d8(f8)
// 95:                     sub, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 96:                     lea, rcx, qwordptr .combiner.test.label 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 97:                     mov, rdx, [rbp-8]                       ;       (sanity req for rdx) [splitter]
rex(48)op(8b)modR/M(55)d8(f8)
// 98:                     call, .main.check                       ; (call label)
op(e8)co32(00-00-00-00)
// 99:                     add, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 100:                     sub, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 101:                     mov, rcx, 3                             ;       (3 req for rcx) [splitter]
rex(48)op(b9)i64(03-00-00-00,00-00-00-00)
// 102:                     mov, rbx, rdx                           ; (preserve) [combiner]
rex(48)op(89)modR/M(d3)
// 103:                     mov, rdx, 3                             ;       (3 req for rdx) [splitter]
rex(48)op(ba)i64(03-00-00-00,00-00-00-00)
// 104:                     mov, r8, 3                              ;       (3 req for r8) [splitter]
rex(49)op(b8)i64(03-00-00-00,00-00-00-00)
// 105:                     call, .combiner.subFunc2                ; (call label)
op(e8)co32(00-00-00-00)
// 106:                     add, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 107:                     mov, rsp, rbp                           
rex(48)op(89)modR/M(ec)
// 108:                     pop, rbx                                
rex(48)op(8f)modR/M(c3)
// 109:                     pop, rbp                                
rex(48)op(8f)modR/M(c5)
// 110:                     ret                                     
op(c3)
// 113: .combiner.test: 
// 114:                 push, rbp                          
rex(48)op(ff)modR/M(f5)
// 115:                 mov, rbp, rsp                      
rex(48)op(89)modR/M(e5)
// 116:                 sub, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 117:                 lea, rcx, qwordptr .combiner.label 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 118:                 call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 119:                 add, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 120:                 sub, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 121:                 mov, rcx, 1                        ;       (1 req for rcx) [splitter]
rex(48)op(b9)i64(01-00-00-00,00-00-00-00)
// 122:                 mov, rdx, 2                        ;       (2 req for rdx) [splitter]
rex(48)op(ba)i64(02-00-00-00,00-00-00-00)
// 123:                 mov, r8, 3                         ;       (3 req for r8) [splitter]
rex(49)op(b8)i64(03-00-00-00,00-00-00-00)
// 124:                 call, .combiner.subFunc1           ; (call label)
op(e8)co32(00-00-00-00)
// 125:                 add, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 126:                 sub, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 127:                 call, .combiner.subFunc1           ; (call label)
op(e8)co32(00-00-00-00)
// 128:                 add, rsp, 32                       ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 129:                 mov, rsp, rbp                      
rex(48)op(89)modR/M(ec)
// 130:                 pop, rbp                           
rex(48)op(8f)modR/M(c5)
// 131:                 ret                                
op(c3)
// 134: .splitter.label:
// 135: .data, "- splitter" <b> 0 
_strdata(2d-20-73-70,6c-69-74-74,65-72)_intdata(00)
// 138: .splitter.test.label:
// 139: .data, "  - simple" <b> 0 
_strdata(20-20-2d-20,73-69-6d-70,6c-65)_intdata(00)
// 142: .splitter.subFunc2:     
// 143:                         push, rbp                    
rex(48)op(ff)modR/M(f5)
// 144:                         mov, rbp, rsp                
rex(48)op(89)modR/M(e5)
// 145:                         mov, rax, rcx                
rex(48)op(89)modR/M(c8)
// 146:                         add, rax, rdx                
rex(48)op(01)modR/M(d0)
// 147:                         goto, .splitter.subFunc2.end ; early return
op(e9)co32(00-00-00-00)
// 149: .splitter.subFunc2.end: 
// 150:                         mov, rsp, rbp                
rex(48)op(89)modR/M(ec)
// 151:                         pop, rbp                     
rex(48)op(8f)modR/M(c5)
// 152:                         ret                          
op(c3)
// 155: .splitter.subFunc1:     
// 156:                         push, rbp                    
rex(48)op(ff)modR/M(f5)
// 157:                         mov, rbp, rsp                
rex(48)op(89)modR/M(e5)
// 158:                         sub, rsp, 32                 ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 159:                         mov, rdx, rcx                ;       (x req for rdx) [splitter]
rex(48)op(89)modR/M(ca)
// 160:                         mov, rcx, 7                  ;       (7 req for rcx) [splitter]
rex(48)op(b9)i64(07-00-00-00,00-00-00-00)
// 161:                         call, .splitter.subFunc2     ; (call label)
op(e8)co32(00-00-00-00)
// 162:                         add, rsp, 32                 ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 163:                         goto, .splitter.subFunc1.end ; early return
op(e9)co32(00-00-00-00)
// 165: .splitter.subFunc1.end: 
// 166:                         mov, rsp, rbp                
rex(48)op(89)modR/M(ec)
// 167:                         pop, rbp                     
rex(48)op(8f)modR/M(c5)
// 168:                         ret                          
op(c3)
// 171: .splitter.test: 
// 172:                 push, rbp                               
rex(48)op(ff)modR/M(f5)
// 173:                 push, rbx                               
rex(48)op(ff)modR/M(f3)
// 174:                 mov, rbp, rsp                           
rex(48)op(89)modR/M(e5)
// 175:                 sub, rsp, 8                             
rex(48)op(83)modR/M(ec)i8(08)
// 176:                 sub, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 177:                 lea, rcx, qwordptr .splitter.label      
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 178:                 call, ._print                           ; (call label)
op(e8)co32(00-00-00-00)
// 179:                 add, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 180:                 sub, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 181:                 mov, rcx, 12                            ;       (12 req for rcx) [splitter]
rex(48)op(b9)i64(0c-00-00-00,00-00-00-00)
// 182:                 call, .splitter.subFunc1                ; (call label)
op(e8)co32(00-00-00-00)
// 183:                 add, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 184:                 xor, rbx, rbx                           
rex(48)op(31)modR/M(db)
// 185:                 cmp, rax, 19                            
rex(48)op(81)modR/M(f8)i32(13-00-00-00)
// 186:                 setet, rbx                              
rex(48)op(0f-94)modR/M(c3)
// 187:                 mov, [rbp-8], rbx                       ; =
rex(48)op(89)modR/M(5d)d8(f8)
// 188:                 sub, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(83)modR/M(ec)i8(20)
// 189:                 lea, rcx, qwordptr .splitter.test.label 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 190:                 mov, rdx, [rbp-8]                       ;       (X req for rdx) [splitter]
rex(48)op(8b)modR/M(55)d8(f8)
// 191:                 call, .main.check                       ; (call label)
op(e8)co32(00-00-00-00)
// 192:                 add, rsp, 32                            ; 32 = (passing size)32 + (align pad)0
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 193:                 mov, rsp, rbp                           
rex(48)op(89)modR/M(ec)
// 194:                 pop, rbx                                
rex(48)op(8f)modR/M(c3)
// 195:                 pop, rbp                                
rex(48)op(8f)modR/M(c5)
// 196:                 ret                                     
op(c3)
