// 2: .main.startLabel:
// 3: .data, "~~ lats start ~~" <b> 0 
_strdata(7e-7e-20-6c,61-74-73-20,73-74-61-72,74-20-7e-7e)_intdata(00)
// 6: .main.endLabel:
// 7: .data, "~~ lats end ~~" <b> 0 
_strdata(7e-7e-20-6c,61-74-73-20,65-6e-64-20,7e-7e)_intdata(00)
// 10: .main.passLabel:
// 11: .data, "    pass" <b> 0 
_strdata(20-20-20-20,70-61-73-73)_intdata(00)
// 14: .main.failLabel:
// 15: .data, "    !!!!!!!! FAIL !!!!!!!!" <b> 0 
_strdata(20-20-20-20,21-21-21-21,21-21-21-21,20-46-41-49,4c-20-21-21,21-21-21-21,21-21)_intdata(00)
// 18: .entrypoint: 
// 19:              push, rbp                           
rex(48)op(ff)modR/M(f5)
// 20:              mov, rbp, rsp                       
rex(48)op(89)modR/M(e5)
// 21:              sub, rsp, 32                        
rex(48)op(83)modR/M(ec)i8(20)
// 22:              lea, rcx, qwordptr .main.startLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 23:              call, ._print                       ; (call label)
op(e8)co32(00-00-00-00)
// 24:              add, rsp, 32                        
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 25:              sub, rsp, 32                        
rex(48)op(83)modR/M(ec)i8(20)
// 26:              call, .splitter.test                ; (call label)
op(e8)co32(00-00-00-00)
// 27:              add, rsp, 32                        
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 28:              sub, rsp, 32                        
rex(48)op(83)modR/M(ec)i8(20)
// 29:              lea, rcx, qwordptr .main.endLabel   
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 30:              call, ._print                       ; (call label)
op(e8)co32(00-00-00-00)
// 31:              add, rsp, 32                        
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 32:              mov, rsp, rbp                       
rex(48)op(89)modR/M(ec)
// 33:              pop, rbp                            
rex(48)op(8f)modR/M(c5)
// 34:              ret                                 
op(c3)
// 37: .main.check:         
// 38:                      push, rbp                          
rex(48)op(ff)modR/M(f5)
// 39:                      push, rbx                          
rex(48)op(ff)modR/M(f3)
// 40:                      mov, rbp, rsp                      
rex(48)op(89)modR/M(e5)
// 41:                      sub, rsp, 8                        
rex(48)op(83)modR/M(ec)i8(08)
// 42:                      sub, rsp, 32                       
rex(48)op(83)modR/M(ec)i8(20)
// 43:                      mov, rbx, rdx                      ; (preserve) [combiner]
rex(48)op(89)modR/M(d3)
// 44:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 45:                      add, rsp, 32                       
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 46:                      cmp, rbx, 0                        
rex(48)op(81)modR/M(fb)i32(00-00-00-00)
// 47:                      je, .main.check.else.0             
op(0f-84)co32(00-00-00-00)
// 48:                      sub, rsp, 32                       
rex(48)op(83)modR/M(ec)i8(20)
// 49:                      lea, rcx, qwordptr .main.passLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 50:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 51:                      add, rsp, 32                       
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 52:                      goto, .main.check.endif.1          
op(e9)co32(00-00-00-00)
// 54: .main.check.else.0:  
// 55:                      sub, rsp, 32                       
rex(48)op(83)modR/M(ec)i8(20)
// 56:                      lea, rcx, qwordptr .main.failLabel 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 57:                      call, ._print                      ; (call label)
op(e8)co32(00-00-00-00)
// 58:                      add, rsp, 32                       
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 59:                      goto, .main.check.endif.1          
op(e9)co32(00-00-00-00)
// 61: .main.check.endif.1: 
// 62:                      mov, rsp, rbp                      
rex(48)op(89)modR/M(ec)
// 63:                      pop, rbx                           
rex(48)op(8f)modR/M(c3)
// 64:                      pop, rbp                           
rex(48)op(8f)modR/M(c5)
// 65:                      ret                                
op(c3)
// 68: .splitter.label:
// 69: .data, "- splitter" <b> 0 
_strdata(2d-20-73-70,6c-69-74-74,65-72)_intdata(00)
// 72: .splitter.test.label:
// 73: .data, "  - simple" <b> 0 
_strdata(20-20-2d-20,73-69-6d-70,6c-65)_intdata(00)
// 76: .main.progress:
// 77: .data, "       progress" <b> 0 
_strdata(20-20-20-20,20-20-20-70,72-6f-67-72,65-73-73)_intdata(00)
// 80: .splitter.subFunc2:     
// 81:                         push, rbp                         
rex(48)op(ff)modR/M(f5)
// 82:                         push, rbx                         
rex(48)op(ff)modR/M(f3)
// 83:                         push, rdi                         
rex(48)op(ff)modR/M(f7)
// 84:                         mov, rbp, rsp                     
rex(48)op(89)modR/M(e5)
// 85:                         sub, rsp, 32                      
rex(48)op(83)modR/M(ec)i8(20)
// 86:                         mov, rbx, rcx                     ; (preserve) [combiner]
rex(48)op(89)modR/M(cb)
// 87:                         lea, rcx, qwordptr .main.progress 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 88:                         mov, rdi, rdx                     ; (preserve) [combiner]
rex(48)op(89)modR/M(d7)
// 89:                         call, ._print                     ; (call label)
op(e8)co32(00-00-00-00)
// 90:                         add, rsp, 32                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 91:                         mov, rax, rbx                     
rex(48)op(89)modR/M(d8)
// 92:                         add, rax, rdi                     
rex(48)op(01)modR/M(f8)
// 93:                         goto, .splitter.subFunc2.end      ; early return
op(e9)co32(00-00-00-00)
// 95: .splitter.subFunc2.end: 
// 96:                         mov, rsp, rbp                     
rex(48)op(89)modR/M(ec)
// 97:                         pop, rdi                          
rex(48)op(8f)modR/M(c7)
// 98:                         pop, rbx                          
rex(48)op(8f)modR/M(c3)
// 99:                         pop, rbp                          
rex(48)op(8f)modR/M(c5)
// 100:                         ret                               
op(c3)
// 103: .splitter.subFunc1:     
// 104:                         push, rbp                         
rex(48)op(ff)modR/M(f5)
// 105:                         push, rbx                         
rex(48)op(ff)modR/M(f3)
// 106:                         mov, rbp, rsp                     
rex(48)op(89)modR/M(e5)
// 107:                         sub, rsp, 8                       
rex(48)op(83)modR/M(ec)i8(08)
// 108:                         sub, rsp, 32                      
rex(48)op(83)modR/M(ec)i8(20)
// 109:                         mov, rbx, rcx                     ; (preserve) [combiner]
rex(48)op(89)modR/M(cb)
// 110:                         lea, rcx, qwordptr .main.progress 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 111:                         call, ._print                     ; (call label)
op(e8)co32(00-00-00-00)
// 112:                         add, rsp, 32                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 113:                         sub, rsp, 32                      
rex(48)op(83)modR/M(ec)i8(20)
// 114:                         mov, rdx, rbx                     ;       (x req for rdx) [splitter]
rex(48)op(89)modR/M(da)
// 115:                         mov, rcx, 7                       ;       (7 req for rcx) [splitter]
rex(48)op(b9)i64(07-00-00-00,00-00-00-00)
// 116:                         call, .splitter.subFunc2          ; (call label)
op(e8)co32(00-00-00-00)
// 117:                         add, rsp, 32                      
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 118:                         goto, .splitter.subFunc1.end      ; early return
op(e9)co32(00-00-00-00)
// 119:                         goto, .splitter.subFunc1.end      ; label decomp
op(e9)co32(00-00-00-00)
// 121: .splitter.subFunc1.end: 
// 122:                         mov, rsp, rbp                     
rex(48)op(89)modR/M(ec)
// 123:                         pop, rbx                          
rex(48)op(8f)modR/M(c3)
// 124:                         pop, rbp                          
rex(48)op(8f)modR/M(c5)
// 125:                         ret                               
op(c3)
// 128: .splitter.test: 
// 129:                 push, rbp                               
rex(48)op(ff)modR/M(f5)
// 130:                 push, rbx                               
rex(48)op(ff)modR/M(f3)
// 131:                 mov, rbp, rsp                           
rex(48)op(89)modR/M(e5)
// 132:                 sub, rsp, 8                             
rex(48)op(83)modR/M(ec)i8(08)
// 133:                 sub, rsp, 32                            
rex(48)op(83)modR/M(ec)i8(20)
// 134:                 lea, rcx, qwordptr .splitter.label      
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 135:                 call, ._print                           ; (call label)
op(e8)co32(00-00-00-00)
// 136:                 add, rsp, 32                            
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 137:                 sub, rsp, 32                            
rex(48)op(83)modR/M(ec)i8(20)
// 138:                 lea, rcx, qwordptr .main.progress       
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 139:                 call, ._print                           ; (call label)
op(e8)co32(00-00-00-00)
// 140:                 add, rsp, 32                            
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 141:                 sub, rsp, 32                            
rex(48)op(83)modR/M(ec)i8(20)
// 142:                 mov, rcx, 12                            ;       (12 req for rcx) [splitter]
rex(48)op(b9)i64(0c-00-00-00,00-00-00-00)
// 143:                 call, .splitter.subFunc1                ; (call label)
op(e8)co32(00-00-00-00)
// 144:                 add, rsp, 32                            
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 145:                 xor, rbx, rbx                           
rex(48)op(31)modR/M(db)
// 146:                 cmp, rax, 19                            
rex(48)op(81)modR/M(f8)i32(13-00-00-00)
// 147:                 setet, rbx                              
rex(48)op(0f-94)modR/M(c3)
// 148:                 mov, [rbp-8], rbx                       ; =
rex(48)op(89)modR/M(5d)d8(f8)
// 149:                 sub, rsp, 32                            
rex(48)op(83)modR/M(ec)i8(20)
// 150:                 lea, rcx, qwordptr .main.progress       
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 151:                 call, ._print                           ; (call label)
op(e8)co32(00-00-00-00)
// 152:                 add, rsp, 32                            
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 153:                 sub, rsp, 32                            
rex(48)op(83)modR/M(ec)i8(20)
// 154:                 lea, rcx, qwordptr .splitter.test.label 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 155:                 mov, rdx, [rbp-8]                       ;       (X req for rdx) [splitter]
rex(48)op(8b)modR/M(55)d8(f8)
// 156:                 call, .main.check                       ; (call label)
op(e8)co32(00-00-00-00)
// 157:                 add, rsp, 32                            
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 158:                 mov, rsp, rbp                           
rex(48)op(89)modR/M(ec)
// 159:                 pop, rbx                                
rex(48)op(8f)modR/M(c3)
// 160:                 pop, rbp                                
rex(48)op(8f)modR/M(c5)
// 161:                 ret                                     
op(c3)
