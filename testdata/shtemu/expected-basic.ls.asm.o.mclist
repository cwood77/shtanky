// 2: .text0:
// 3: .data, "text 0" <b> 0 
_strdata(74-65-78-74,20-30)_intdata(00)
// 6: .text1:
// 7: .data, "text 1" <b> 0 
_strdata(74-65-78-74,20-31)_intdata(00)
// 10: .text2:
// 11: .data, "text 2" <b> 0 
_strdata(74-65-78-74,20-32)_intdata(00)
// 14: .virtFunc0: 
// 15:             push, rbp                 
rex(48)op(ff)modR/M(f5)
// 16:             mov, rbp, rsp             
rex(48)op(89)modR/M(e5)
// 17:             sub, rsp, 32              
rex(48)op(83)modR/M(ec)i8(20)
// 18:             lea, rcx, qwordptr .text2 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 19:             call, ._print             ; (call label)
op(e8)co32(00-00-00-00)
// 20:             add, rsp, 32              
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 21:             mov, rsp, rbp             
rex(48)op(89)modR/M(ec)
// 22:             pop, rbp                  
rex(48)op(8f)modR/M(c5)
// 23:             ret                       
op(c3)
// 26: .virtFunc1: 
// 27:             push, rbp                 
rex(48)op(ff)modR/M(f5)
// 28:             mov, rbp, rsp             
rex(48)op(89)modR/M(e5)
// 29:             sub, rsp, 32              
rex(48)op(83)modR/M(ec)i8(20)
// 30:             lea, rcx, qwordptr .text2 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 31:             call, ._print             ; (call label)
op(e8)co32(00-00-00-00)
// 32:             add, rsp, 32              
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 33:             mov, rsp, rbp             
rex(48)op(89)modR/M(ec)
// 34:             pop, rbp                  
rex(48)op(8f)modR/M(c5)
// 35:             ret                       
op(c3)
// 38: .vinst:   
// 39:           goto, .virtFunc0
op(e9)co32(00-00-00-00)
// 40:           goto, .virtFunc1
op(e9)co32(00-00-00-00)
// 43: .ctor:    
// 44:           push, rbp                 
rex(48)op(ff)modR/M(f5)
// 45:           push, rbx                 
rex(48)op(ff)modR/M(f3)
// 46:           mov, rbp, rsp             
rex(48)op(89)modR/M(e5)
// 47:           lea, rbx, qwordptr .vinst 
rex(48)op(8d)modR/M(1d)disp32toLabel(00-00-00-00)
// 48:           mov, [rcx], rbx           ; =
rex(48)op(89)modR/M(19)
// 49:           mov, rsp, rbp             
rex(48)op(89)modR/M(ec)
// 50:           pop, rbx                  
rex(48)op(8f)modR/M(c3)
// 51:           pop, rbp                  
rex(48)op(8f)modR/M(c5)
// 52:           ret                       
op(c3)
// 55: .entrypoint: 
// 56:              push, rbp                 
rex(48)op(ff)modR/M(f5)
// 57:              push, rbx                 
rex(48)op(ff)modR/M(f3)
// 58:              mov, rbp, rsp             
rex(48)op(89)modR/M(e5)
// 59:              sub, rsp, 8               
rex(48)op(83)modR/M(ec)i8(08)
// 60:              lea, rcx, [rbp-8]         ; o
rex(48)op(8d)modR/M(4d)d8(f8)
// 61:              sub, rsp, 32              
rex(48)op(83)modR/M(ec)i8(20)
// 62:              call, .ctor               ; (call label)
op(e8)co32(00-00-00-00)
// 63:              add, rsp, 32              
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 64:              sub, rsp, 32              
rex(48)op(83)modR/M(ec)i8(20)
// 65:              mov, rbx, rcx             ; (preserve) [combiner]
rex(48)op(89)modR/M(cb)
// 66:              lea, rcx, qwordptr .text0 
rex(48)op(8d)modR/M(0d)disp32toLabel(00-00-00-00)
// 67:              call, ._print             ; (call label)
op(e8)co32(00-00-00-00)
// 68:              add, rsp, 32              
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 69:              sub, rsp, 32              
rex(48)op(83)modR/M(ec)i8(20)
// 70:              call, [rbx]               ; (vtbl call)
rex(48)op(ff)modR/M(13)
// 71:              add, rsp, 32              
rex(48)op(81)modR/M(c4)i32(20-00-00-00)
// 72:              mov, rsp, rbp             
rex(48)op(89)modR/M(ec)
// 73:              pop, rbx                  
rex(48)op(8f)modR/M(c3)
// 74:              pop, rbp                  
rex(48)op(8f)modR/M(c5)
// 75:              ret                       
op(c3)
